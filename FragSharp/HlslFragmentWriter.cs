using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Roslyn.Compilers;
using Roslyn.Compilers.CSharp;

namespace FragSharp
{
    internal class HlslFragmentWriter : HlslWriter
    {
        public HlslFragmentWriter(SemanticModel model, Compilation compilation)
            : base(model, compilation)
        {
        }

        int SamplerNumber = 0;

        public string CompileFragmentMethod(MethodDeclarationSyntax method)
        {
            ClearString();
            
            // Declare samplers and other relevant structures needed for the Fragment Shader
            Write(FileBegin());
            EndLine();
            
            WriteLine();

            CompileFragmentSignature(method);
            EndLine();

            // Referenced methods
            Write(ReferencedMethodsPreamble());
            EndLine();
            Write("<$0$>"); // This is where we will insert referenced methods.
            
            WriteLine();

            // Fragment Shader method
            Write(FragmentShaderBegin());
            var PrevIndent = Indent();
            CompileStatement(method.Body);
            RestoreIndent(PrevIndent);
            Write(FragmentShaderEnd());
            EndLine();

            WriteLine();

            Write(FileEnd());

            // We must wait until after compiling the shader to know which methods that shader references.
            string methods = GetReferencedMethods();
            
            // Now get the full string written so far and insert the referenced methods.
            string fragment = GetString();
            fragment = SpecialFormat(fragment, methods);

            return fragment;
        }

        override protected void CompileReturnStatement(ReturnStatementSyntax statement)
        {
            BeginLine("__FinalOutput.Color{0}={0}", Space);
            CompileExpression(statement.Expression);
            EndLine(";");

            WriteLine("return __FinalOutput;");
        }

        string FragmentShaderBegin()
        {
            return string.Format(
@"// Auto-generated fragment shader
PixelToFrame FragmentShader(VertexToPixel psin)
{{
{0}PixelToFrame __FinalOutput = (PixelToFrame)0;", Tab);
        }

        string FragmentShaderEnd()
        {
            return "}";
        }

        string FileBegin()
        {
            return string.Format(
@"// This file was auto-generated by FragSharp. It will be regenerated on the next compilation.
// Manual changes made will not persist and may cause incorrect behavior between compilations.

// Vertex shader data structure definition
struct VertexToPixel
{{
{0}float4 Position   : POSITION0;
{0}float4 Color      : COLOR0;
{0}float2 TexCoords  : TEXCOORD0;
{0}float2 Position2D : TEXCOORD2;
}};

// Fragment shader data structure definition
struct PixelToFrame
{{
{0}float4 Color      : COLOR0;
}};

// Vertex Shader
VertexToPixel StandardVertexShader( float2 inPos : POSITION0, float2 inTexCoords : TEXCOORD0, float4 inColor : COLOR0)
{{
{0}VertexToPixel Output = (VertexToPixel)0;    

{0}Output.Position.w = 1;
    
{0}Output.Position.x = (inPos.x - xCameraPos.x) / xCameraAspect * xCameraPos.z;
{0}Output.Position.y = (inPos.y - xCameraPos.y) * xCameraPos.w;

{0}Output.Position2D = Output.Position.xy;

{0}Output.TexCoords = inTexCoords;
{0}Output.Color = inColor;
    
{0}return Output;
}}", Tab);
        }

        string ReferencedMethodsPreamble()
        {
            return
@"// The following methods are included because they are referenced by the fragment shader.";
        }

        string FileEnd()
        {
            return string.Format(
@"// Shader compilation
technique Simplest
{{
{0}pass Pass0
{0}{{
{0}{0}VertexShader = compile VERTEX_SHADER StandardVertexShader();
{0}{0}PixelShader = compile PIXEL_SHADER FragmentShader();
{0}}}
}}", Tab);
        }

        void CompileFragmentSignature(MethodDeclarationSyntax method)
        {
            var ParameterList = method.ParameterList.Parameters;
            if (ParameterList.Count == 0) return;

            var last = ParameterList.Last();
            foreach (var parameter in ParameterList)
            {
                CompileFragmentParameter(parameter);
                EndLine();

                if (parameter != last)
                {
                    WriteLine();
                }
            }
        }

        void CompileFragmentParameter(ParameterSyntax parameter)
        {
            string type = parameter.Type.ToString();

            if (type == "UnitField")
            {
                CompileSamplerParameter(parameter);
            }
        }

        void CompileSamplerParameter(ParameterSyntax parameter)
        {
            SamplerNumber++;

            Write(
@"// Texture Sampler for UnitField {2}, using register location {1}
Texture {2};
sampler {2}Sampler : register(s{1}) = sampler_state
{{
{0}texture   = <{2}>;
{0}MipFilter = Point;
{0}MagFilter = Point;
{0}MinFilter = Point;
{0}AddressU  = Wrap;
{0}AddressV  = Wrap;
}};", Tab, SamplerNumber, parameter.Identifier.ValueText);

        }
    }
}
